open Printf

module type ATOM = sig
  type t
  val t: t Irmin.Type.t
  val compare: t -> t -> int
end

module In_edge_type = 
	 struct 
	 type t = (string * int64)
	 let t = let open Irmin.Type in pair string int64 
	 let compare = Pervasives.compare
	end 

module Make =
  struct
   (* labels for nodes **)
   module OL = Mlist.Make(In_edge_type)
   type nlabel = string
   
   (* labels for edges *)
   type elabel = string

   (* node *)
   type node = int64

   (* labelled node *) 
   type lnode = (node * nlabel)

   (* edge containing pairs of node *)
   type edge = (node * node)

   (* labelled edge *)
   type ledge = (edge * elabel)

   (* path is the list of node *)
   type path = node list

   (* labelled path is the list of labelled node *)
   type lpath = lnode list

   (* labelled link from a node *)
   (* here label represents the edge label *)
   type in_edge = OL.t

   (* labelled link to a node *)
   (* here label represents he edge label *)
   type out_edge = OL.t

   (* pair of link to the node, node, label, link from the node 
      node represented by node type, label represented by label type, 
      in_edge reprsents the edges from its predecessors 
      to it and out_edge represents the edges to its successors. *)
   type context = (in_edge * node * nlabel * out_edge)
    

   (* A graph is either an empty graph or a graph extended by a new node v together with its 
      label and with edges to its succesors and predecessors that
      are already in the graph *)
   (* It is not similar to list because it cannot be freely generated by Empty and G *)
   type t = 
           | E_G 
           | G of (context * t)

    exception Empty

   let empty = E_G

   let is_empty g = function 
     | E_G -> true 
     | G a -> false 

   (* check whether node n belongs to a context c or not *)
   let belongs_node_c n = function 
     | (il, a, l, ol) -> if n = a then true else false 


   (* get the node referred in the context c *)
   let get_node c = match c with 
     | (il, n, l, rl) -> n
   
   (* get the edge directed towards the node n *)
   let get_in_edge = function 
      | (il, n, l, ol) -> il 
  
   (* get the edge directed from the node n *)
   let get_out_edge = function 
      | (il, n, l, ol) -> ol 

   let rec get_in_edge_g n g = match g with 
    | E_G -> []
    | G(x, xl) -> if (get_node x = n) then get_in_edge x else 
                   get_in_edge_g n xl

   let rec get_out_edge_g n g = match g with 
    | E_G -> []
    | G(x, xl) -> if (get_node x = n) then get_out_edge x else 
                   get_out_edge_g n xl

   (* get the label referred in the context c *)
   let get_label c = match c with 
     | (il, n, l, rl) -> l
    
   (* get the node with its label referred in the context c *)
   let get_node_with_label c = function 
     | (il, n , l , rl) -> (n, l)
    
   (* check whether a node is present in the graph or not *)
   let rec check_node n = function 
     | E_G -> raise Empty 
     | G (x, xl) -> if (get_node x = n) then true else check_node n xl

   (* get the context for a node n in the graph *)
    let rec get_context n g = match g with 
     | E_G -> raise Empty 
     | G (x, xl) -> if (get_node x = n) then x else get_context n xl

    let rec filter_successor n l (c : out_edge) = match c with 
     | [] -> []
     | x :: xl -> if (((snd x) = n) && ((fst x) = l)) then xl else x :: filter_successor n l xl

    let rec filter_predecessor n l c = match c with 
     | [] -> []
     | x :: xl -> if ((snd x) = n) && ((fst x) = l) then xl else x :: filter_predecessor n l xl

    let rec filter_p_s n c = match c with 
     | [] -> []
     | x :: xl -> if ((snd x) = n) then xl else x :: filter_p_s n xl

   (* gives the degree of any node n *)
   let rec degree n = function 
    | E_G -> 0 
    | G (x, xl) -> if (get_node x = n) then (List.length (get_in_edge x)) + 
                                            (List.length (get_out_edge x)) 
                                       else (degree n xl)

   (* gives list of all the nodes present in the graph g *)
   let rec get_nodes g = match g with 
    | E_G -> []
    | G (x, xl) -> get_node x :: (get_nodes xl)
   
   (* gives all the nodes along with its label present in the graph g *)
   let rec get_nodes_with_label g = match g with 
    | E_G -> []
    | G (x, xl) -> get_node_with_label x :: (get_nodes_with_label xl)


   let rec add_context c g = match g with 
    | E_G -> G(c, E_G)
    | G (x, xl) -> let x' = add_context c xl in 
                   G (x, x')
 

   (* gives the number of nodes present in the graph *)
   let number_of_nodes g = List.length (get_nodes g)

   (* gives the list of successors nodes for a node n *)
   let rec succ n = function
    | E_G -> []
    | G (x, xl) -> if (get_node x = n) then List.map (snd) (get_out_edge x) 
                                       else succ n xl

   (* gives the list of predecessor nodes for a node n *)
   let rec pred n = function
    | E_G -> []
    | G (x, xl) -> if (get_node x = n) then List.map (snd) (get_in_edge x) 
                                       else pred n xl

   let rec update_context n c' = function
    | E_G -> E_G 
    | G(x, xl) -> if (get_node x) = n 
                  then G(c', xl) else G(x, (update_context n c' xl))

   let rec update_all_context n = function
    | E_G -> E_G 
    | G(x, xl) -> G(((filter_p_s n (get_in_edge x)),
                   (get_node x),
                   (get_label x),
                   (filter_p_s n (get_out_edge x))), update_all_context n xl)

   (* insert node n *)
   let rec insert_node n l p s = function
    | E_G -> G ((p, n, l, s), E_G)
    | G (x, xl) -> (add_context (p,n,l,s) (G(x,xl)))                   

   (* insert the edge from v to w with label l *)
   let rec insert_edge v w l = function 
    | E_G -> raise Empty 
    | G (x, xl) -> if (get_node x = v) then G((get_in_edge x,
    	                                       get_node x,
    	                                       get_label x,
                                               List.append [(l,w)] (get_out_edge x)),
                                               xl) 
                                       else G(x, insert_edge v w l xl)

   (* delete edge from v to w *)
   let rec delete_edge v w l = function 
    | E_G -> raise Empty 
    | G (x, xl) -> if (get_node x = v) 
                   then if (List.mem (l,w) (get_out_edge x)) 
                        then G (((get_in_edge x), 
                   	             (get_node x), 
                   	             (get_label x), 
                   	             (filter_successor w l (get_out_edge x))), xl)
                        else  let c' = get_context w (G(x, xl)) in 
                              let c = ((filter_predecessor w l (get_in_edge x)),
                        	           (get_node c'),
                        	           (get_label c'),
                        	           (get_out_edge c')) in 
                             (update_context w c (G(x,xl)))
                  else G (x, (delete_edge v w l xl))
    
   (* delete node n *)
   let rec delete_node n = function 
    | E_G -> raise Empty 
    | G (x, xl) -> if (get_node x = n) then (update_all_context n xl)
                                       else delete_node n xl

   (* check the membership of a context in g *)
   let rec is_mem_G c g = match g with 
    | E_G -> false
    | G(x, xl) -> if x = c then true else is_mem_G c xl

   (* get all the edges in the context c*)
   let get_edges_in_context c = function 
     | (p, n, l, s) -> 
       let rec get_in_edge el = 
       match p with
       | []-> []
       | (x :: xl) -> (snd x, n) :: get_in_edge xl in 
       let rec get_out_edge el = 
       match s with 
       | [] -> []
       | (y :: yl) -> (n, snd y) :: get_out_edge yl in 
      List.append (get_in_edge p) (get_out_edge s) 

    (* get all edges in graph g *)
    let rec get_edges g = match g with 
      | E_G -> []
      | G (x, y) -> get_edges_in_context x :: get_edges y 

    let rec get_diff e1 e2 = match (e1, e2) with 
      | [], [] -> []
      | [], _ -> []
      | _, [] -> e1
      | x :: xl, y :: yl -> if List.mem x e2 
                            then get_diff xl e2
                            else x :: get_diff xl e2


    let rec merge2 g1 g2 = match (g1, g2) with 
     | E_G, E_G -> E_G 
     | E_G, _ -> g2 
     | _, E_G -> g1 
     | G(x, xl), G(y, yl) -> 
        if (get_node x) = (get_node y) 
         then if (get_in_edge x) = (get_in_edge y)
               then if (get_out_edge x) = (get_out_edge y)
                     then let gl = merge2 xl yl in
                          G(x, gl)
                     else begin 
                          let oe = OL.merge [] (get_out_edge x) (get_out_edge y) in 
                          G ((get_in_edge x, get_node x, get_label x, oe), merge2 xl yl)
                          end
               else begin 
                    let oi = OL.merge [] (get_in_edge x) (get_in_edge y) in 
                    let oo = OL.merge [] (get_out_edge x) (get_out_edge y) in 
                    G ((oi, get_node x, get_label x, oo), merge2 xl yl)
                    end 
        else insert_node (get_node x) 
                         (get_label x) 
                         (get_in_edge x) 
                         (get_out_edge y) 
                         (merge2 xl (G (y, yl)))

    (*let rec merge o g1 g2 = match (o,g1, g2) with 
      | E_G, E_G, E_G -> E_G
      | _, E_G, E_G -> E_G 
      | E_G, _, E_G -> g1 
      | E_G, E_G, _ -> g2 
      | E_G, _, _ -> merge2 g1 g2 
      | _, _, E_G -> merge2 o g1 
      | _, E_G, _ -> merge2 o g2
      | G(x1, xl1), G(x2, xl2), G(x3, xl3) ->
        when x1 = x2 && x2 = x3 then 
        G(x1, (merge xl1 xl2 xl3))
      | G(x1, xl1), G(x2, xl2), G(x3, xl3) ->
        if x1 = x2 then 
           if x2 = x3 
           then G(x1, (merge xl1 xl2 xl3))
           else if *)




                                            
   (* Merging *)
   type edit = 
    | Delete_node of node 
    | Delete_edge of node * node * elabel 
    | Insert_node of node * nlabel * in_edge * out_edge 
    | Insert_edge of node * node * elabel

 (* let rec edit_distance g1 g2 = match (g1, g2) with 
    | E_G, E_G -> []
    | E_G, G(x, xl) -> Insert_node 
                       (get_node x, 
                        get_label x, 
                        get_in_edge x, 
                        get_out_edge x) :: edit_distance E_G xl 
    | G(x, xl), E_G -> Delete_node (get_node x) :: edit_distance xl E_G
    | G(x, xl), G(y, yl) -> if ((get_node x) = (get_node y)) then 
                             if (get_in_edge x) = (get_in_edge y) 
                              then if (get_out_edge x) = (get_out_edge y)
                                      then x :: edit_distance xl yl 
                                      else begin 
                                           let dd = get_diff (get_out_edge x) (get_out_edge y) in 
                                           let di = get_diff (get_out_edge y) (get_out_edge x) in 
                                           let li = List.map (fun x y -> Insert_edge (fst x) (get_node y) 


                                      (get_in_edge x, get_node x, get_label x, get_out_edge x)
                              else  *)
     









   let print_int64 i = output_string stdout (string_of_int (Int64.to_int i))

   let print_list f lst = 
    let rec print_elements = function
      | [] -> ()
      | x :: xl -> f x ; print_elements xl in 
    print_string "[";
    print_elements lst;
    print_string "]"

    let print_pair f f' p = 
     let rec print_elements = function 
     | (x,y) -> (f x, f' y) in 
     print_string "(";
     print_elements p;
     print_string ")"

   let print_adj_list l = print_list (print_pair (print_string) (print_int64)) l

   let print_c f f' f'' c = 
     let rec print_elements = function
      | (p, n, l, s) ->
         f' p ;
         f n ;
         f'' l; 
         f' s in 
        print_string "}";
        print_elements c;
        print_string "}" 

   let rec print_graph g = match g with 
       | E_G -> print_string "E_G"
       | G (a, x) -> (print_list (print_pair (print_string) (print_int64)) (get_in_edge a)) ;
       	              print_int64 (get_node a);
       	              print_string (get_label a);
                      (print_list (print_pair (print_string) (print_int64)) (get_out_edge a));
                      print_string "&"; 
                      print_graph x





 end